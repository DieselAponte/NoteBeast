 Consideraciones:
No se crea tabla de usuario, ya que se trata de una app local de un solo usuario.
Se usan claves for谩neas donde es relevante, por ejemplo, para vincular ProgressEntry y Note con Project.
Las listas (objectives, resourcePaths) se modelan en tablas separadas, ya que SQLite no tiene arrays ni listas.
Enums (TaskStatus, Priority) se manejan como TEXT con validaci贸n de valores v谩lidos.

 Ventajas de no tener una tabla de usuario
Ya que la app es local y para un solo usuario, no necesitas control de acceso, autenticaci贸n ni multitenencia. Esto simplifica el dise帽o y evita sobreingenier铆a.
UserConfig se asume con una 煤nica fila, sin id.

Tareas pendientes:
-Validaci贸n de la creaci贸n de las tablas para la base de datos
-Implementaci贸n de los ConcreteRepositorys
-Verificar la utilidad de Singleton para manejar la conexi贸n de SQLite como SQLiteManager o ConfigManager.
-Implementaci贸n del patr贸n facade para facilitar y agregar una capa de abstracci贸n a los Services
-Revisi贸n de los patrones creacionales como Builder para los Settings, Task, Project, Note debido a que estos tienen campos opcionales.Factory para la creaci贸n de vistas o controladores din谩micamente desde el SceneManager o ViewLoader.
-Revisi贸n del patron State para la mascota y posible codificaci贸n de esta en el paquete entity, revisar requerimientos para su creaci贸n.

Tareas siguientes:
-Consideraci贸n de base de datos NoSQL para el manejo de JSON en el ProgressEntry cuando se trata del area de proyectos.
-Verificar la utilidad de Adapter para los m煤ltipes tipos de archivos compatibles (.txt .json .pdf)
-Revisi贸n de patrones de Comportamiento como el Observer para la configuraci贸n del usuario respecto al theme de la app o fuente para que los componentes deben de actualizarse autom谩ticamente.
-Command para la implementaci贸n de deshacer/rehacer de edici贸n de notas o cambios en las tareas.
Strategy para ordenamiento de tareas o priorizaci贸n (Por fecha, urgencia, tipo)